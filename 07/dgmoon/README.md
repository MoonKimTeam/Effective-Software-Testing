# Chapter 07 테스트 가능성을 위한 설계

테스트 할 수 있는, 테스트 하기 쉬운 시스템을 지향해야

테스트 가능성: 테스트 대상 시스템이나 클래스, 메서드에 대해 얼마나 자동 테스트를 쉽게 작성할 수 있는지

테스트가 어렵다면 아무도 테스트를 하려고 하지 않을 것

코드 설계 시 테스트 가능성은 항상 고려해야 함

스파게티 코드를 작성하는 것이, 상호협력적이고 응집력 있으며 테스트 하기 쉬운 코드 작성하는 것보다 쉬움

but, worth it.

테스트 하기 쉽고 좋은 코드 -> 고품질 코드를 보장하기 위한 유일한 방법

## 도메인 코드에서 인프라 코드 분리

도메인 - 시스템의 핵심. 비즈니스 규칙, 로직, 엔티티 서비스 등.

인프라스트럭처 - 외부 의존성 다루는 코드와 관련. DB 쿼리 다루는 코드 등.

두 코드가 섞여 있으면 테스트하기 어려움

책임이 클수록 더 복잡해지고 버그가 발생할 가능성이 증가함

사용자 인터페이스도 섞여있으면 테스트 가능성 저해

명확한 책임 분리 필요 -> 포트와 어댑터(육각형 아키텍처 패턴)

도메인은 인프라에 직접 의존하기보다 포트를 사용(알리스테어 콕번)

포트 - 인프라가 할 수 있는 일을 정의한 인터페이스

어댑터 - 포트의 구현체. DB나 웹서비스와 통신함.

책임을 분리 -> 의존성이 없으니 단위테스트도 쉬워짐(스터빙 통해서)

포트를 스텁과 모의 객체로 만들어서 도메인 로직 동작을 쉽게 수행 가능

## 의존성 주입과 제어 가능성

클래스를 완전히 제어, 관찰 가능하게 해야 함

테스트 불가능한 코드 만드는 법

- 어댑터 인스턴스 생성
- 어댑터를 직접 사용

의존성 직접 생성은 클래스 내부를 직접 제어하지 못하게 하고 모의 객체 단위 테스트를 불가능하게 함

세터를 사용하여 의존성 주입하여 테스트 가능성 높임

의존성 주입의 이점

- 테스트 도중 모의 객체나 스텁 만들게 해줌. 생산성 증대.
- 의존성 명확하게 해줌. 의존성은 모두 주입으로 해결
- 관심사 분리. 의존성 생성 방법 걱정 없음
- 클래스 확장성 가짐

인터페이스(포트)를 고안하여 관심사를 더 잘 분리할수 있고, 계층 간의 결합 줄일 수 있으며, 계층 간 상호작용 단순화

의존성 역전: 고수준 모듈은 저수준 모듈에 의존해서는 안 됨. 추상화는 세부사항에 의존 안 함

모든 것을 인터페이스로 하는 건 품이 많이 듦으로 적절하게 캡슐화하자.

## 클래스 및 메서드를 관찰 가능하게 하기

테스트 코드는 클래스 행동을 쉽게 조사할 수 있어야

- 단언을 보조하는 메서드 도입(반환 값 있을 때)
    - 모키토 API 사용하여 스파이 이용
    - 새로운 메서드 추가(isReadyForDelivery)
- void 메서드의 행위 관찰하기
    - ArgumentCaptor 이용
      but, 테스트 가능성 개선 위한 설계변경은 오직 작은 변경만

## 의존성 전달방법: 클래스 생성자, 메서드 매개 변수

생성자를 통한 의존성 전달 방법과 메서드에 값 직접 전달 방법은 트레이드 오프

생성자를 통한 방법은 전체 클래스와 테스트의 복잡도를 약간 증가시킴. but, 클라이언트 클래스 단순화
메서드 매개변수를 이용한 방법은 클래스와 테스트를 단순화. but, 클라이언트 복잡도 증가

## 현업

테스트 작성 시 주의사항

### 테스트 대상 클래스의 응집도

응집도: 아키텍처상의 모듈, 클래스, 메서드 또는 어떤 요소든지 단 하나의 책임을 가지는 것

코드에 있을 수 있는 문제 증상 및 징후

- 응집력이 없는 클래스에 대한 테스트 스위트는 거대함
- 응집력 없는 클래스는 크기가 커지는 일을 멈추지 않음 -> SRP, OCP 위반

### 테스트 대상 클래스의 결합

응집력 있는 클래스 사용, 여러 클래스 조합 -> 결합도 높아짐

과도한 결합은 진화를 해칠 수 있음. 한 클래스의 변경점이 명확하지 않은 방법으로 다른 클래스에 전파될 수 있기 때문

결합도 높은 클래스 징후

- 클래스 테스트 시 수많은 의존성 인스턴스 필요 시 -> 클래스 재설계
- ATest 클래스의 테스트가 실패 했는데 디버깅 해보니 BTest에 문제가 있는 경우

### 복잡한 조건 테스트 가능성

조건 + 분기 커버리지 기준 적용하면 매우 많은 테스트 고안 가능

### private 메서드와 테스트 가능성

private 메서드는 응집도가 떨어지고 복잡하기 때문에 분리해서 테스트 하고 싶은 욕구

현재 위치에서 있어서는 안 되는 메서드일 수 있음

-> 일반적인 리팩터링 방법: 메서드 추출해서 다른 클래스로 옮김

### 정적 메서드, 싱글턴 패턴과 테스트 가능성

정적 메서드 -> 테스트 가능성에 악영향

가능하면 유틸리티 메서드 제외하고 정적 메서드 만들지 말자

프레임워크 정적 메서드 -> 추상화를 그 위에 추가하는 것이 좋음

싱글턴 패턴 -> 테스트 가능성 저하

싱글턴 사용 시스템 테스트 시 다른 테스트 케이스에서 싱글턴을 재설정, 교체하기위한 추가 코드 작성 필요

### 육각형 아키텍처의 설계 기법으로써 모의 객체

모키스트들은 어떤 기능을 개발하고 다른 곳에서 무언가 필요할 때마다 포트 드러냄

포트는 어댑터의 구현체를 신경쓰지 않고 나머지 기능을 개발할 수 있도록 해주는 인터페이스

### 테스트 용이성을 위한 설계 관련 추가 자료

테스트 가능성에 관한 책들

- 마이클 페더스, <레거시 코드 활용 전략>
- 스티브 프리먼 & 냇프라이스, <테스트 주도 개발로 배우는 객체지향 설계와 실천>
- 로버트 마틴, <클린 아키텍처>