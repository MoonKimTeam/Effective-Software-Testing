# 테스트 가능성을 위한 설계

**테스트 가능성**은 테스트 대상 시스템이나 클래스, 메서드에 대해 자동 테스트를 얼마나 쉽게 작성할 수 있는지를 말한다.

<br>


## 도메인 코드에서 인프라 코드를 분리하기

**도메인**은 시스템의 핵심이 있는 곳이다. 모든 비즈니스 규칙, 로직, 엔티티, 서비스 및 이와 유사한 요소들이 들어있다. <br>
**인프라스트럭처**는 외부 의존성을 다루는 코드와 관련이 있다. 예를 들면 DB 쿼리, 웹 서비스 호출, 파일 읽기/쓰기 등이다. <br>
도메인 코드와 인프라 코드가 섞여 있을때 시스템을 테스트하기 까다롭다.

<img width="562" alt="스크린샷 2024-06-03 오후 8 45 32" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/b7cbdd80-20c6-4c46-bdee-08346b552cf5">

<br>

예를 들어, 다음과 같은 요구사항을 지닌 온라인 쇼핑몰이 있다.

- 쇼핑 카트를 배송 준비 상태로 설정하고, 새로운 상태를 DB에 영속화한다.
- 상품을 고객에게 전달해야 한다고 배송 센터에 알린다.
- SAP 시스템에 알린다.
- 고객에게 결제가 잘 이루어졌다는 이메일을 보낸다. 이메일은 배송 예상 날짜를 포함해야 하고, 이 정보는 배송 센터 API로 알 수 있다.

<img width="713" alt="스크린샷 2024-06-03 오후 8 47 58" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/6f12aa3f-bb3d-429b-b036-54188b35744f">
<img width="751" alt="스크린샷 2024-06-03 오후 8 49 40" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/5f58b10a-73ed-4fb9-934a-4fb3f9885362">

<br>

## 의존성 주입과 제어 가능성

도메인과 인프라 클래스가 서로 가지게 될 추상적인 상호작용을 나타내는 인터페이스(포트)를 고안함으로써, 우리는 관심사를 더 잘 분리할 수 있고, 계층간의 결합을 줄이고 상호작용을 단순하게 할 수 있다. <br>
도메인 클래스는 어댑터에 직접 의존하지 않고, 어댑터가 하는 일이 추상적으로 정의된 인터페이스에 의존한다.  <br>
**의존성 역전 원칙**은 이러한 개념을 공식화하는데 도움이 된다.

- 고수준 모듈은 저수준 모듈에 의존해서는 안된다. 이 둘 모두는 추상화에 의존해야 한다.
- 추상화는 세부사항에 의존하면 안된다. 세부사항은 추상화에 의존해야 한다.

<img width="589" alt="스크린샷 2024-06-03 오후 8 54 58" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/3462ae8e-0ae7-4404-b595-46c60059d9aa">

<br>

추상화에 의존하면 단위 테스트할 때 의존성을 모의하거나 스텁으로 만들 때 도움이 된다. <br>
모의하는 클래스가 복잡하면 테스트는 작성하기 힘들어진다. 포트, 어댑터, 의존성 역전 원칙을 염두에 두고 있으면 포트의 인터페이스는 자연스럽게 단순해진다. <br>
포트가 제공하는 메서드는 대개 응집력이 있고 요점이 명확하다.

<br>

## 클래스 및 메서드를 관찰 가능하게 하기

클래스 수준에서의 관찰 가능성은 기능이 기대했던 대로 동작하는지를 얼마나 쉽게 단언할 수 있는가에 관한 것이다. <br>
예를 들면, 클래스가 내부에서 속성을 변경하는데 속성에 대한 게터를 제공할 수 없거나 하고 있지 않은 경우, 클래스에 간단한 isValid 메서드를 제공해서 클래스가 유효한 상태인지를 반환하는 식이다.

테스트 코드는 클래스의 행동을 쉽게 조사할 수 있어야 한다. 프로그램이 기대한대로 동작하는지 관찰하기 어렵다면, 클래스가 관찰 가능한지를 생각해보자. <br>
테스트 보조로 게터나 해결책을 도입하는 것을 마다하지 말자. 행위를 관찰하면 테스트 코드가 매우 쉬워진다.

<img width="733" alt="스크린샷 2024-06-03 오후 9 05 27" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/da780214-71c9-44cd-ade3-d8829a17af89">
<img width="743" alt="스크린샷 2024-06-03 오후 9 05 31" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/a8a276e8-b4f1-49ec-bb6d-148b8d5e303a">

<br>

## 의존성 전달 방법: 클래스 생성자와 메서드 매개변수

생성자를 통해 의존성을 클래스에 전달하는 방법과, 메서드에 직접 값을 전달하는 방법 중 어느 것을 설계에 반영할지 결정해야 하는 일은 흔한 일이다. <br>
옳거나 그른 방법은 없고, 최선의 선택을 내리기 위한 트레이드오프를 이해해야 한다.

<img width="543" alt="스크린샷 2024-06-03 오후 9 08 41" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/37b794a1-4179-4f69-8904-a7aac5038b72">

ChristmasDiscout 클래스는 지금이 크리스마스인지, 크리스마스 할인을 적용해야 하는지 알기 위해 현재 날짜가 필요하다. <br>
이 클래스는 날짜를 얻기 위해 현재 날짜를 구하는 방법을 알고 있는 의존성 클래스인 Clock을 사용한다. <br>
Clock 스텁을 사용해서 원하는 아무 날짜나 시뮬레이션할 수 있기 떄문에 테스트하는 일은 쉽다. <br>
**하지만 어떤 클래스를 스텁으로 만드는 일은 스텁을 사용하지 않을 때보다 복잡하다.**

<br>

<img width="719" alt="스크린샷 2024-06-03 오후 9 10 18" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/ce867c92-ce8e-4594-b9a7-c5ef538030df">

이 메서드는 테스트하기 쉽다. 어떤 LocalDate 객체라도 메서드로 전달할 수 있기 때문에 모의 객체가 필요없다.

<br>

> 의존성을 전혀 사용하지 않고 메서드 매개변수를 통해 원하는 값을 전달하는 방법의 장단점을 알아보자. <br>
> 이 클래스를 호출하는 모든 곳에서 인수를 제공해야 한다는 단점이 있다. (ChristmasDiscount는 today가 전달되기를 바란다.) <br>
> 따라서 ChristmasDiscount가 Clock에 의존하지 않더라도, 호출하는 쪽에서 Clock에 의존할 것이다.

<br>

## 현업에서의 테스트 가능성 설계

1. 테스트는 테스트 대상 클래스의 인스턴스를 생성한다.
2. 테스트는 테스트 대상 메서드를 호출한다.
3. 테스트는 메서드가 기대한대로 동작했는지 단언한다.

이런 각 단계에 대한 수행 난이도를 계속해서 살펴보아야 한다. <br>
테스트 대상 클래스의 인스턴스를 만들기가 어렵다면, 의존성을 줄여 설계할 수 있을 것이다. <br>
테스트 대상 메서드를 호출하기 어렵다면, 사전 조건을 더 다루기 쉽게 하는 방법이 있을 것이다. <br>
아마 메서드가 수행하는 일을 쉽게 관찰할 수 있도록 하는 설계 방법이 있을 것이다.

### private 메서드와 테스트 가능성

원칙적으로 테스트는 private 메서드를 오로지 public 메서드를 통해서만 테스트해야 한다. <br>
하지만 종종 특정 private 메서드만 분리해서 테스트하고 싶은 욕구를 느낀다.

이런 느낌이 드는 이유는 대개 private 메서드의 응집도가 떨어지고 복잡하기 때문이다. <br>
이 메서드는 public 메서드와 매우 다른 작업을 수행하거나, 작업이 너무 복잡해서 분리해서 테스트해야 한다. <br>
이것은 테스트가 우리에게 무언가를 알려주는 좋은 예시이다.

### 정적 메서드, 싱글턴, 테스트 가능성







