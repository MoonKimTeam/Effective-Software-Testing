# 구조적 테스트와 코드 커버리지

## 코드 커버리지, 올바른 방법

코드 커버리지 도구(jacoco)를 이용하여 코드 커버리지를 이용하면, 놓친 분기가 얼마나 되는지 알 수 있다. <br>
이를 활용하여 수행하지 않은 부분을 찾아서, 왜 수행되지 않았는지 이해하고 놓친 테스트 케이스를 추가할 수 있다.

## 구조적 테스트

<img width="726" alt="스크린샷 2024-05-15 오후 8 50 20" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/51769f58-b574-4333-ad04-2de8354fdeb9">

이 접근법에서 가장 중요한 점은 **구조적 테스트는 명세 기반 테스트로 고안한 테스트 스위트를 보강** 한다는 것이다. <br>
코드 커버리지는 수행하지 않은 부분을 자동으로 찾아준다.

## 반복문과 유사 구조 처리하기

완벽한 테스트는 불가능하기 때문에, 테스터는 **반복 경계 기준**을 적용해서 언제 반복 테스트를 중지할지 결정한다. <br>
테스트 스위트는 반복문에 대해서만 이 기준을 만족하도록 한다.

- 반복문을 0번 수행하는 테스트 케이스
- 반복문을 1번 수행하는 테스트 케이스
- 반복문을 여러 번 수행하는 테스트 케이스

여러 번 수행하는 테스트 케이스의 경우, 테스트 수행 횟수를 결정하기 위해 프로그램과 요구사항에 대해 충분히 이해해야 한다.

## 경계 테스트와 구조적 테스트

경계는 소스 코드에서 찾기 쉽다. 접점 및 거점을 찾아내고 테스트를 수행하는 방식은 구조적 테스트에 잘 들어맞는다. *(ex. if문)*

- if (pad <= 0): 접점은 0이며 표현식을 true로 평가하는 점이다. 거점은 접점에 가장 가까우면서 표현식을 false로 평가하는 점이다. 이 경우에서는 pads가 정수형일 때 1
- if (pads == padLen): 점접은 padLen. 등식이고 padLen이 정수형이므로 거점은 두 개. 하나는 pads == padLen - 1, 다른 하나는 pads = padLen + 1
- if (pad < padLen): 접점은 padLen - 1. 거점은 식을 false로 평가하는 점이고, padLen이 된다.

## 현업에서의 구조적 테스트

### 코드 커버리지에 대한 생각

사람들은 커버리지 숫자를 무작정 보면 안된다고 주장한다. <br>
코드 커버리지가 달성해야 할 숫자일 뿐이라면, 덜 유용한 테스트 케이스를 만들고 측정 게임을 끝내버릴 수 있다. <br>
구조적 테스트와 코드 커버리지를 통해, 명세 기반 테스트를 강화하고, 테스트 스위트가 수행하지 않는 코드 부분을 찾아내며 놓쳤던 구획을 찾을 수 있다.

### 무엇을 수행하지 말아야 할까 ?

<img width="770" alt="스크린샷 2024-05-15 오후 9 05 45" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/eacf7d44-245c-4ecf-afc6-44212686a4da">

코드 커버리지를 100% 달성하려면 catch 블록을 수행해야 한다. 그렇게 하기 위해서는 toURI 메서드가 강제로 예외를 던지도록 해야한다. <br>
하지만 그렇게 해서 얻는 이점은 적고, resourceFolder가 RuntimeException을 던질 때 시스템의 나머지 부분에서 무슨 일이 일어나는지 테스트하는 것이 더 중요하다. <br>
우리는 자바의 toURI() 메서드보다 resourceFoler 메서드를 더 제어할 수 있기 때문이다.

**모든 코드는 다른 방식으로 증명될 때까지 수행되어야 한다.**


















