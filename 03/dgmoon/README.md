# Chapter 03 구조적 테스트와 코드 커버리지

명세 테스트 다음 -> `소스 코드`를 바탕으로 테스트 스위트 확장

1. 요구사항 분석 시 구획 한두 개 빼먹어도 소스 코드 보는 동안 포착 가능
2. 문서에 명시되어 있지 않은 언어 구조, 알고리즘 및 데이터 구조 등 구현 세부사항 테스트해야

- jacoco 라이브러리를 사용한 코드 커버리지 확인
- 테스트를 놓치는 이유: 개발자가 요구사항 명세를 놓침. 명세 내용 누락 혹은 불명확. 명세에 기술되지 않은 코드.

## 구조적 테스트: 소스 코드의 구조를 사용하여 테스트를 도출하는 것

- 커버리지 기준을 알고 있어야

## 구조적 테스트 단계

1. `명세 기반 테스트` 수행
2. 구현사항 읽고, 개발자 주요 결정사항 이해
3. 코드 커버리지 도구 수행
4. 수행 안 된 코드에 대해 이해하고 테스트할 가치 있는지 결정
    - 테스트가 필요하면 자동화된 테스트 케이스 구현
5. 소스코드 바탕으로 고안할 만한 다른 테스트 찾기

* 구조적 테스트는 항상 이전의 명세 기반 테스트로 고안한 테스트 스위트를 보강한다.(and 반복적)

## 커버리지 기준

- 줄 커버리지: 테스트가 해당 줄을 수행하는지(어떤 식으로든 건드리기만 하면 됨)
- 분기 커버리지: 분기 지시문(if, for, while 문) 기준. 그래프의 모든 간선을 수행했을 때 커버리지가 100% 달성 됨
- 조건 + 분기 커버리지: 분기문의 각 조건도 고려. 조건 기준.
- 경로 커버리지: 수행할 수 있는 모든 실행 경로 수행(가장 강력한 기준, costly, 달성 불가능)

## 복잡한 조건과 MC/DC(Modified Condition/Decision Coverage) 커버리지 기준

- MC/DC: 조건의 조합 고려. 모든 조합이 아닌 `중요한 조합`만.
- 각 매개변수의 가능한 모든 조건은 적어도 한 번은 결과에 영향을 주어야 함
- 예시
    - `if (A && (B || C))`에 대해
    - 조건 A가 true인 테스트 케이스(T1)
    - 조건 A가 false인 테스트 케이스(T2)
    - T1 ,T2가 서로 다른 결과를 내야 함
    - T1의 변수 B, C는 T2의 B, C에 대해 동등한 true/false 값 가짐

    - 조건 B가 true인 테스트 케이스(T3)
    - 조건 B가 false인 테스트 케이스(T4)
    - T3 ,T4가 서로 다른 결과를 내야 함
    - T3의 변수 A, C는 T4의 A, C에 대해 동등한 true/false 값 가짐

    - 조건 C가 true인 테스트 케이스(T5)
    - 조건 C가 false인 테스트 케이스(T6)
    - T5 ,T6가 서로 다른 결과를 내야 함
    - T5의 변수 A, B는 T6의 A, B에 대해 동등한 true/false 값 가짐

    - MC/DC 커버리지를 100% 달성하는데 필요한 테스트의 개수는 결정계수 N + 1(가능한 조합 총개수 2^N 보다 작음)

- 경로 커버리지를 달성하려던 테스트보다 비용 절감 가능

## 반복문과 유사구조 처리하기

- 반복문 블록 마다 테스트하는 완벽한 테스트는 불가 -> 반복 경계 적합 기준 적용
    - 반복문을 0번 수행하는 테스트
    - 반복문을 1번 수행하는 테스트
    - 반복문을 여러 번 수행하는 테스트

## 기준 포함과 선택

- 일부 커버리지 전략은 다른 전략을 포함함
    - 경로 커버리지 > MC/DC > 분기 + 조건 커버리지 > 분기 커버리지, 조건 커버리지 > 코드 줄 커버리지

## 명세 기반 테스트와 구조적 테스트 - leftPad() 사례

## 경계 테스트와 구조적 테스트

- 경계는 명세보다 소스 코드에서 훨씬 찾기 쉬움
- if문을 분석하거나 반복문 경계 기준을 이용해서 경계를 찾기

## 구조적 테스트만으로는 불충분

- 구조적 테스트만으로는 효과적이지만 탄탄하지 않음
- 커버리지를 100% 달성해도 흥미로운 테스트 케이스를 빼먹을 수 있음

## 현업에서의 구조적 테스트

- 코드 커버리지 비선호 이유: 커버리지 숫자에만 집착하는 건 유용하지 않은 테스트만 만들고 끝나버릴 수 있음, but 놓쳤던 구획 찾을 수 있음
    - 구조적 테스트 지지 근거
        - 더 나은 에러 방지 효과
        - 커버리지, 규모와 테스트 효과의 상관 관계
        - 돌연변이 오류를 잘 예측하게 됨 -> 품질에 도움
        - `낮은 커버리지는 테스트가 제대로 되지 않은 것`
- 커버리지 100%의 의미
    - 코드 줄 커버리지 = 수행한 코드 줄 수 / 전체 코드 줄 수 * 100(%)
    - 분기 커버리지 = 수행한 분기 수 / 전체 분기 수 * 100(%)
    - 조건 + 분기 커버리지 = (수행한 분기의 수 + 수행한 조건의 수) / (분기의 수 + 조건의 수) * 100(%)
- 어떤 커버리지 기준을 사용할 것인가
    - 상황에 따라 다름
    - 필자는 분기 커버리지 선호. 복잡한 표현식 -> 조건 + 분기 커버리지 필요성 평가.
- 표현식이 너무 복잡 -> MC/DC 사용
    - but, 모든 경우에 적용한 것은 아님
- 그 외 커버리지 기준
    - 데이터 흐름 커버리지 -> 다루지 않음
- 수행하지 말아야 하는 것들
    - catch 블록
    - equals(), hashCode() 메서드
    - 직관적인 getter, setter 메서드
    - but, 모든 코드는 다른 방식으로 증명될때까지 수행돼야 한다.
    - 100% 달성을 기본적으로 목표로 해보고 필요 없는 코드는 제외해 나감.
    - but, 버그는 경험적으로 테스트 잘 수행하지 않은 부분에서 발생하는 경향 있음

## 돌연변이 테스트

- 커버리지 만으로는 테스트 스위트의 품질 알 수 없음
- 테스트 스위트의 오류 감지 능력?
- 돌연변이 테스트: 코드에 일부러 버그 주입하여 테스트 스위트를 검사
    - 버그 주입한 테스트가 통과되면 문제 있음
    - 가정
        - 유능한 프로그래머 가설: 유능한 프로그래머의 구현은 올바르거나 단순 오류 조합으로 정확한 프로그램이 됨
        - 커플링 효과: 복잡한 버그는 많은 작은 버그가 모여 발생함
        - 따라서, 테스트가 작은 버그 잡을 수 있으면 복잡한 것도 잡을 수 있을 것
- 돌연변이 테스트 도구 예 -> 파이테스트
    - 조건부 경계
    - 증분
    - 음수 반전
    - 산술 연산자
    - 참 반환
    - 조건 제거
- 매우 많은 돌연변이 생성해야 해서 costly, but 매우 유익(분기 커버리지보다 약점 추가 발견)