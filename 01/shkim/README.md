# 효율적이고 체계적인 소프트웨어 테스트

소프트웨어 테스트의 전부는 **버그 찾기**이다. <br>
개발자로서 제품의 품질을 책임져야 하고, 테스트는 그런 책임감을 갖는 데 도움을 줄 수 있는 유일한 도구이다.

## 테스트를 하는 개발자와 하지 않는 개발자

테스트를 자동화하지 않는 개발자들은, 작업이 완료되면 애플리케이션을 실행하고 몇 가지 입력값을 넣어본다. <br>
테스트 코드가 없다면 수동 테스트를 진행해야 하고, 수많은 경우를 테스트하려면 시간이 너무 오래 걸린다.

테스트 케이스를 형식화하여 자동화된 테스트를 작성한다면 나중에 프로그램이 퇴행하지 않도록 해준다. <br>
어쩌면 6개월 후에 다른 개발자가 코드를 보며 왜 이렇게 작성되어 있는지 이해하지 못하고 제거하려고 할 때, 테스트가 그런 실수를 알려주도록 보장할 것이다.

<img width="727" alt="스크린샷 2024-05-06 오후 8 48 22" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/dfc70d00-2978-4619-a384-254e12faaf41">

<br>

## 개발자를 위한 효율적인 소프트웨어 테스트

- 일단 명세를 완성하고 나서 코드에 초점을 맞추고 **구조적 테스트(코드 커버리지)** 를 통해 현재의 테스트 케이스가 충분한지 평가한다.
- 몇몇 테스트 케이스에 대해서는 **예시 기반 테스트(테스트를 위해 한 가지 데이터 포인트를 고름)** 을 사용한다.
- 특이한 경우에 대해서는 **속성 기반 테스트** 를 사용해서 코드에서 발생할 수 있는 버그를 쉽게 찾아내도록 한다.
- 계약과 스스로 고안한 방법의 사전, 사후 조건을 살펴본다.

### 효율적이면서 체계적이라는 것의 의미

**효율적**이라는 말은 올바른 테스트를 작성하는데 집중해야 함을 뜻한다. <br>
소프트웨어 테스트와 연관된 모든 것은 트레이드오프 관계이다. 테스터는 버그를 찾기 위해 들여야 하는 노력을 최소화하면서 최대한 많은 버그를 찾기 원한다. <br>
이를 이루기 위해서는 무엇을 테스트해야 하는지 알면 된다.

**체계적**이라는 말은 어떤 코드 조각에 대해 어느 개발자라도 같은 테스트 스위트를 만들어낸다는 것을 의미한다. <br>
두 개발자가 같은 프로그램에 대해 다른 테스트 스위트를 만들어내는 일은 흔하다. <br>
우리는 프로세스를 체계화해서 그 일을 하는 개발자가 누가 되었든 상관없도록 할 수 있어야 한다.

<br>

## 소프트웨어 테스트 원칙 (테스트는 왜 이렇게 어려운가)

### 완벽한 테스트트 불가능하다

우리에게는 프로그램을 완벽히 테스트할 수 있는 자원이 없다. <br>
300개의 다른 플래그를 설정값으로 지닌 소프트웨어 시스템이 있다고 생각해보자. <br>
300개 플래그에 두 가지 값이 가능하다면 2^300개의 조합을 테스트해야 한다.

### 테스트를 그만둘 때를 파악하기

테스트를 너무 적게 작성하면 의도한 대로 동작하지 않는 소프트웨어 시스템을 만들게 된다. <br>
반면 명확한 가정 없이 계속 테스트를 작성하는 것은 비효율적인 테스트가 될 수 있다. <br>
우리의 목표는 비용을 최소화하며 최대한 많이 버그를 찾는 것이다. 이 목표를 달성하기 위해 테스트를 언제 그만둘지 결정하는데 도움이 되는 적절함이 필요하다.

### 버그는 다른 곳에 비해 많이 발생하는 지점이 있다

테스트 케이스에 우선순위를 정할 때 버그가 균일하게 분포되어 있지 않다는 점에 유의하자. <br>
예를 들면, 결제 모듈은 마케팅 모듈보다 훨씬 엄격한 테스트가 필요할 수 있다. 이러한 경향을 **결함 클러스터링** 이라고 한다.

### 검증은 유효성 검사가 아니다

오류없이 동작하지만 사용자에게 쓸모없는 소프트웨어 시스템은 좋은 시스템이 아니다. <br>
소프트웨어 테스터가 검증에만 몰두하고 검사에 신경을 많이 쓰지 않을 때 이러한 에러 부재의 오류를 맞닥뜨린다. <br>
**검증은 시스템이 제대로 되어 있는가에 관한 것이라면, 유효성 검사는 올바른 시스템을 가지는 방법에 관한 것이다.**

<br>

## 테스트 피라미드와 집중해야 할 부분

### 단위 테스트

단위를 격리해서 테스트하는 것을 **단위 테스트**라고 하고, 다음과 같은 장점이 있다.

- 단위 테스트는 빠르다.
- 단위 테스트는 다루기 쉽다.
  - 단위 테스트는 어떤 인수를 메서드에 전달하고, 메서드의 반환값과 기대하는 결과를 비교하는 방식으로 소프트웨어를 테스트한다. 입력값과 기대값ㅇ은 테스트에 적용하고 수정하기 쉽다.
- 단위 테스트는 작성하기 쉽다.

단점으로는 아래와 같다.

- 현실성이 떨어진다.
  - 시스템의 수많은 클래스와 클래스 간 상호작용으로 인해 실제 애플리케이션은 단위 테스트에서와는 다르게 동작할 수 있다.
- 잡을 수 없는 종류의 버그가 존재한다.
  - 어떤 버그는 백엔드와 프론트엔드를 통합했을 때만 드러낸다. 또는 멀티스레드 코드는 단위 수준으로 테스트할 수 있더라도 일단 스레드가 동시에 수행되기 시작하면 버그가 나타날 수 있다.


### 통합 테스트

통합 테스트는 우리의 코드와 외부 요소 간의 통합을 테스트해야 할 때 사용하는 테스트 수준이다. <br>
단위 테스트에 비하면 작성하기 더 어렵고, 테스트에 사용할 데이터베이스를 설정하는데 노력이 든다.

<img width="391" alt="스크린샷 2024-05-09 오후 9 13 27" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/f4f8be18-3568-4b95-be8e-7a9ffdaad9d7">

### 시스템 테스트

시스템이 가진 모든 데이터베이스, 프론트엔드 및 기타 구성요소를 포함한 전체 소프트우에어 시스템을 실행해야 한다. <br>
시스템 내부가 어떻게 동작하는지는 관심없고, 특정 입력을 주면 출력이 어떻게 나오는지에만 관심이 있다. <br>
시스템 테스트의 장점은 **테스트가 현실적**이라는 것이다. <br>
단점으로는 단위 테스트에 비해 느리고, 작성하기 힘들고, 불안정한 경향이 있다.

<img width="661" alt="스크린샷 2024-05-09 오후 9 15 43" src="https://github.com/MoonKimTeam/Effective-Software-Testing/assets/87420630/32192c1c-99e7-4900-9697-c196ddfe973e">



















