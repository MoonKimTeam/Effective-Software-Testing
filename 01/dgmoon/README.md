# Chapter 01 효율적이고 체계적인 소프트웨어 테스트

- 테스트가 중요한 이유
    - 코드 품질, 코드에 대한 책임감 향상
    - 버그 찾기 도움
    - 체계적인 자동화된 테스트 필요 <- 수동 테스트는 너무 시간이 오래 걸리고, 주먹구구식 테스트는 코너 케이스 놓치기 쉬움
    - 코드가 퇴행하는 것을 방지

## 테스트 대상 - 플래닝 포커 예제

1. 유효하지 않은 입력(널 리스트, 빈 리스트, 한 요소 리스트)
2. 정상 동작(good weather)
    - 경곗값 테스트
    - 예시 기반 테스트 - JUnit (가능한 입력 중 하나의 특정 입력만 골라 테스트)
    - 속성 기반 테스트 - jqwik (무작위 생성된 입력 중 임의의 입력만 골라 테스트)
        - @ForAll - @Provide 이름 기반
        - @Property
        - @Provide
3. 계약, 사전 조건, 사후 조건 확인

# 개발자를 위한 효율적인 소프트웨어 테스트

- 효율적인 테스트 프로세스
    1. 요구사항 분석
    2. 테스트 주도 개발
    3. 단위(클래스, 메서드)들의 계약을 고려. 테스트 용이성 염두해야
    4. 도메인 테스트(요구사항을 세분화하여 테스트 케이스 도출), 경계 테스트, 구조적 테스트
    5. 대규모 테스트(통합 테스트, 시스템 테스트) <- 도메인 테스트, 경계 테스트, 구조적 테스트 사용
    6. 다양한 기법과 지능형 테스트 도구 사용하여 테스트 케이스 생성, 돌연변이 테스트, 정적 분석
    7. 배포

- 반복 프로세스임. 폭포수 개발 모형이 아니다.(순서도 엄격하게 정해져 있지 않아 왔다갔다 가능)
- 개발에 집중하고 나서 테스트
- 제대로 된 설계 미신 - 코드가 단순하다고 버그가 없어지는 것은 아님. 단순함이 테스트를 대체할 수 없다.
- 테스트 -> costly but worth it
- 효율적이면서 체계적 -> 효율적: 최소 노력으로 최대 많은 버그 찾기(무엇을 테스트 할지 제대로 인식하면 됨). 체계적: 모든 개발자가 같은 테스트 스위트를 만들어냄.
- 테스트 자동화의 역할 -> 테스트 자동화(JUnit 프레임워크를 사용하는 등)는 테스트 케이스가 버그를 드러내는 데 도움을 주는 도구일뿐. `테스트 케이스 설계`/`테스트 실행` 분리하여 생각

## 테스트 원칙

- 완벽한 테스트는 불가능 -> 따라서 효율적인 테스트 필요(우선순위에 따라)
- 테스트를 그만둘 때가 언제인가 -> 테스트가 적으면 버그가 많아지지만 그렇다고 명확한 가정 없이 테스트 작성하는 것은 비효율적
- 가변성이 중요 -> no silver bullet. 하나의 테스트 기법은 그 기법의 한계가 그 테스트의 한계임(살충제 역설). 다양한 전략을 결합하자.
- 다른 곳에 비해 빈발하는 버그 지점 있음(결함 클러스터링)
- 어떤 테스트든지 불충분 -> 테스트는 버그가 없음을 보여주는 것. 버그가 아예 존재하지 않음을 보이려는 게 아님(데이크스트라). `모든 것을 테스트할 순 없다.`
- 맥락이 핵심 - 모바일은 모바일, 임베디드는 임베디드, 웹은 웹에 맞는 테스트 방식이 존재함
- 검증(verification)은 유효성 검사(validation) 아님 - 검증은 시스템이 제대로 되어 있는지에 관한 것, 유효성 검사는 올바른 시스템을 가지는 방법

## 테스트 피라미드

- 단위 테스트(빠르고, 다루기 쉬움, 작성 용이, but 비현실적, uncatchable bugs, 단위를 정하기 어려움)
- 통합 테스트(시스템의 경계를 넘어 구성요소를 사용할 때 테스트, 단위 테스트보다 작성하기 어려움)
- 시스템 테스트(DB, 프런트엔드, 기타 구성요소를 포함한 전체 시스템 실행하여 테스트, 가장 현실적 -> 더 확신할 수 있다. but 느림, 작성하기 힘듦, 불안정)
- 수동 테스트(탐색적 테스트)

- 테스트 수준별로 언제 사용해야 할지는 상황마다 다름

- 단위 테스트 선호 이유 - 작성 용이, 빠름, 제품 코드와 엮어서 만들 수 있음
    - 저자는 정말 중요한 부분에 대해서는 통합 테스트와 시스템 테스트를 사용한다고 함
    - 다른 수준에서 모든 기능을 다시 테스트 할 필요는 없음

- 수준별 테스트 대상
    - 시스템 알고리즘이나 단일 비즈니스 로직 관련은 단위 테스트 사용
    - 대상 구성요소가 상호작용할 때마다 통합 테스트를 사용(DAO와 DB 간), but 통합 테스트는 비용이 많이 들고 설정이 어려우므로 통합 테스트가 유일한 방법일 때만
    - 시스템 테스트는 매우 costly -> 무엇을 테스트해야 할지 우선순위 정하고 위험성 분석을 수행해야(버그 발생시 시스템 어느 부분에 가장 치명적일지)
    - 모든 테스트는 자동화돼야 하지만 수동 테스트도 가치는 있음

- 테스트 피라미드에 반대 -> 테스트 트로피(통합 테스트 > 시스템 테스트, 단위 테스트), DB 위주 시스템은 통합 테스트 > 단위 테스트 선호, but 경험, 취향의 문제
    - 테스트의 범위보다 크기가 중요
        - 작은 테스트 - 단일 프로세스에서 테스트 가능 -> 빠르지만 안정
        - 중간 크기 테스트 - 여러 프로세스에 걸쳐 실행 -> 다소 느리고 더 불안정
        - 큰 테스트 - 로컬 호스트 뿐만 아니라 다른 컴퓨터를 호출, e2e 테스트)
        - 결국, 목표는 테스트 효과를 극대화 하는 것. 테스트 비용을 줄이고, 빠르게 실행, 시스템 품질에 대한 더 많은 피드백 줘야

## 용어

- 코너 케이스 - 알고리즘 또는 문제의 '극단적인' 조건, 즉 입력 값의 범위나 조건의 한계점에서 발생하는 특이한 상황 극단치
- 엣지 케이스 - 시스템의 경계 조건에서 발생하는 상황. 경곗값(경계치)
- 유효성 검사(validation) vs. 검증(verification) - 올바른 시스템인지와 시스템이 올바른 과정을 통해 만들어졌는지
    - Validation(타당성 확인): 소프트웨어의 사양과 성과물이 사용자 요구와 의도된 용도에 적합한지, 그리고 소프트웨어 개발을 통해 해당 요구사항을 일관되게 만족시키고 있다는 객관적인 증거를 제시하는 것
    - Verification(검증): 소프트웨어 개발 라이프 사이클에 있는 특정 단계에서의 설계 결과가 그 단계에 입력된 명확한 요구사항 대비 전부 적합하다는 객관적인 증거를 제시하는 것
- 단위 테스트: DB나 웹 서비스 등 외부 시스템에 의존하지 않는 단위(클래스 세트, 클래스, 메서드)를 테스트 하는 것. 혹은 그 테스트를 수행하는 자동화된 코드 조각.
- 통합 테스트: 테스트 대상 코드가 시스템의 경계를 넘어 다른 구성 요소를 사용하는 경우에 그 코드와 외부 요소간의 통합을 테스트 하는 것
  

