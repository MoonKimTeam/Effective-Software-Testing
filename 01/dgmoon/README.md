# Chapter 01 효율적이고 체계적인 소프트웨어 테스트


- 테스트가 중요한 이유
  - 코드 품질 향상, 자신감
  - 체계적인 자동화된 테스트 필요 <- 주먹구구식 테스트는 코너 케이스 놓치기 쉬움
  - 코드가 퇴행하는 것을 방지

- 테스트가 어려운 이유, 버그 없는 시스템 존재하지 않는 이유

- 테스트 피라미드


극단치
코너케이스
엣지케이스
경곗값(경계치)

테스트 대상
1. 유효하지 않은 입력
2. 정상 동작(good weather)
   - 경곗값 테스트

예시 기반 테스트 X - JUnit
속성 기반 테스트 - jqwik
 - @ForAll - @Provide 이름 기반
 - @Property
 - @Provide

계약, 사전 조건, 사후 조건

효율적인 테스트 프로세스
1. 요구사항 분석
2. 테스트 주도 개발
3. 단위(클래스, 메서드), 단위들의 계약을 고려. 테스트 용이성 염두해야
4. 도메인 테스트 경계 테스트, 구조적 테스트
5. 대규모 테스트(통합 테스트, 시스템 테스트) <- 도메인 테스트 경계 테스트, 구조적 테스트 사용
6. 지능형 테스트 도구 사용하여 테스트 케이스 생성, 돌연변이 테스트, 정적 분석
7. 배포

반복 프로세스임. 폭포수 개발 모형이 아니다.

개발에 집중하고 나서 테스트

제대로 된 설계 미신 - 코드가 단순하다고 버그가 없어지는 것은 아님. 단순함이 테스트를 대체할 수 없다.

테스트 -> costly but worth it

효율적이면서 체계적 -> 효율적: 올바른 테스트 작성에 집중. 체계적: 모든 개발자가 같은 테스트 스위트를 만들어냄

테스트 자동화의 역할 - > 테스트 자동화(JUnit 프레임워크를 사용하는 등)는 테스트 케이스가 버그를 드러내는 데 도음을 주는 도구일뿐

완벽한 테스트는 불가능 -> 따라서 효율적인 테스트 필요(우선순위에 따라)
테스트를 그만둘때가 언제인가 -> 테스트가 적으면 버그가 많아지지만 그렇다고 명확한 가정 없이 테스트 작성하는 것은 비효율적
가변성이 중요 -> no silver bullet X 하나의 기법은 그 기법의 한계가 테스트의 한계임(살충제 역설)
다른 곳에 비해 빈발하는 버그 지점 있음(결함 클러스터링)
어떤 테스트든지 불충분 -> 테스트는 버그가 없음을 보여주는 것. 버그가 아예 존재하지 않음을 보이려는 게 아님
맥락이 핵심 - 모바일은 모바일, 임베디드는 임베디드, 웹은 웹
검증(verification)은 유효성 검사(validation) 아님 - 검증은 시스템이 제대로 되어 있는지에 관한 것, 유효성 검사는 올바른 시스템을 가지는 방법

테스트 피라미드
- 단위 테스트(빠르고, 다루기 쉬움, 작성 용이, but 비현실적, uncatchable bugs, 단위를 정하기 어려움)
- 통합 테스트(시스템의 경계를 넘어 구성요소를 사용할 때 테스트, 단위 테스트보다 작성하기 어려움)
- 시스템 테스트(DB, 프런트엔드, 기타 구성요소를 포함한 전체 시스템 실행하여 테스트, 가장 현실적 -> 더 확신할 수 있다. but 느림)
- 수동 테스트(탐색적 테스트)

테스트 수준별로 언제 사용해야 할지는 상황마다 다름

단위테스트 선호 이유 - 작성 용이, 빠름, 제품 코드와 엮어서 만들 수 있음

저자는 정말 중요한 부분에 대해서는 통합테스트와 시스템 테스트를 사용한다고 함

각 수준 테스트 대상
    - 대상 구성요소가 상호작용할 때마다 통합테스트를 사용(DAO와 DB 간) but 통합 테스트는 비용이 많이 들고 설정이 어려우므로 통합 테스트가 유일한 방법일 때만

테스트 피라미드에 비동의 -> 테스트 트로피(통합테스트 > 시스템 테스트, 단위테스트), DB 위주 시스템은 통합테스트 > 단위 테스트 선호

테스트의 범위보다 크기가 중요
- 작은 테스트 - 단일 프로세스에서 테스트 가능
- 중간크기 테스트 - 여러 프로세스에 걸쳐 실행
- 큰 테스트 - 로컬 호스트 뿐만 아니라 다른 컴퓨터를 호출, e2e테스트)







