# Chapter 04 계약 설계

- 제약사항 모델링
    - 클래스가 다른 클래스를 유효하지 않은 입력으로 절대로 호출하지 못하도록 하기: 코드 단순화 but 복잡
    - 방어적 작성. 비유효 입력 -> 시스템 중단, 에러 메시지 전달: 시스템 탄력화 but 비생산적
    - best: 개발 중인 클래스에 명확한 계약을 정의

## 사전 조건 사후 조건

- 사전 조건: 예) 음수 값을 받을 수 없음
- 사후 조건: 예) 음수 값을 반환하지 않음
- 문서에 사전 사후 조건을 명확히 기술하는 것은 매우 중요(Javadoc 활용)

### 단언 키워드(assert) - 활성화 필요

assert 문으로 사전, 사후 조건을 명시적으로 나타낼 수 있음

assert를 쓸지, 예외를 던질 지는 팀에서 결정할 사항

- AssertionError라는 획일화된 오류 던지므로 쓰지 말자는 주장도 있음
- 간단함

### 강한 조건, 약한 조건

- 조건의 강도: 프로그램을 중지하거나(강) 비유효 값도 받도록 하기, -1(에러 값)이나 0 반환하기 등(약)
- 강한 조건은 실수의 범위를 줄여주긴 하지만, 조건을 단언문으로 바꾸면서 코드가 복잡해짐

cf) 계약에 의한 설계(DbC, Design by Contract, 마이어)
저자의 관점은 DbC보다 더 실용적

## 불변식

- 불변식: 사전, 사후에 모두 유지되어야 하는 "조건"
- 단언, if문 등 어떤 것으로 구현해도 ok
- 불변식 테스트는 5장 속성 기반 테스트에서 설명

## 계약 변경과 리스코프 치환 법칙

- 계약 변경 시 그 변경으로 인한 영향 파악 필요
- 상속과 계약: 서브 타입핑으로 계약을 서로 다르게 적용할 수 있음
- 리스코프 치환 법칙: 시스템에 기대하는 동작을 깨뜨리지 않고 자식 클래스를 부모 클래스로 치환할 수 있는 개념

## 게약에 의한 설계와 테스트

- 이점
    - 단언문을 통해 버그를 일찍 발견 가능
    - 사전 조건, 사후 조건, 불변식은 테스트 대상을 제공(테스트를 보강)
    - 명시적인 계약은 소비자 편익을 증가시킴(소비자가 올바르게 사용하면 작업은 정상적으로 수행됨)

## 현업

### 강한 사전 조건 vs. 약한 사전 조건

- 약한 사전 조건 메서드: 클라이언트가 사용하기 편함, but 메서드에 비유효 입력 다루도록 하는 추가 부담
- 강한 사전 조건 메서드: 추가 부담은 클라이언트에 있음, but 클라이언트가 사전 조건 위반 확인 필요

### 입력 유효성 검사 vs. 계약 vs. 둘 다

입력 유효성 검사를 수행했다면 계약(사전, 사후 조건 모델링)이 필요 없을지도?
-> 둘은 다르기 때문에 둘 다 이뤄져야 함

유효성 검사는 잘못된 값 입력 시 올바른 데이터인지 확인 후 메시지 반환
계약은 클래스간 의사소통이 문제 없이 일어나도록 함

대신 중복 피하자 -> 입력 유효성 검사를 수행했다면 객체 생성자에서 사전 조건으로 확인하지 않기

### 단언 vs. 예외

자바에서는 명확한 계약 확인 메커니즘을 제공하지 않기 때문에 개발자들이 예외 선호

- 라이브러리나 유틸 클래스 계약 모델링 -> 예외 선호
- 비즈니스 클래스와 클래스 간 계약 모델링 & 이전 MVC 레이어에서 데이어 정제됨 -> 단언문 선호
- 비즈니스 클래스와 클래스 간 계약 모델링 & 이전 MVC 레이어에서 데이어 정제됐는지 모름 -> 예외 선택
- 유효성 검사 -> 예외나 단언 둘 다 아닌 더 세련된 방식 선호.
    - 유효성 검사 실패 시 유효성 검사를 중지하지 않고 오류 전체 목록(검사 통과하지 못한 항목들) 표시 선호
    - 많은 코드가 요구되는 복잡한 유효성 검사 모델링 가능

RuntimeException 같은 순수 자바 예외보다 NegativeValueException 같은 전문적, 의미 있는 예외를 사용하자

### 예외 vs. 부드러운 반환값

클라이언트를 좀 더 단순하게 만드려면 예외보다 부드러운 반환 값 사용

- 클라이언트가 어떻게 다뤄야 할지 모르는 동작 발생 -> 예외(프로그램 중단)
- 부드러운 값을 반환해서 계속 작업할 수 있도록 할 수 있다면 -> 부드러운 값 반환

### 계약에 의한 설계(DbC) 사용하지 않는 경우 -> 사용하지 말아야 할 타당한 이유 없음

사전 조건, 사후조건, 불변식을 코드에 명시하는 일은 시간과 비용이 많이 들지 않으므로 DbC 고려 권장

DbC가 테스트 필요성을 대체하지 않음 -> 사전, 사후 조건, 불변식 만으로는 모든 예상 동작 표현 불가능

### 사전 조건, 사후 조건, 불변식에 대한 테스트 작성 여부

유효성 검사에 대해서는 작성, 단언문에 대해서는 작성 거의 안 함

### 지원 도구

- IntelliJ의 @Nullable, @NotNull 애너테이션 - 컴파일 시 적절한 assert문으로 변경
- Bean Validation